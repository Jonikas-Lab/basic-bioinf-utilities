#! /usr/bin/env python2.7

"""
Split a fastq file into multiple files based on the index (only indexes listed with -i option; others go in _unmatched.fq file).

Assumes the index is the last ":"-separated field of the sequence ID.
 -- Weronika Patena, 2015
USAGE: deepseq_split_indexes.py -i indexes infile outfile_basename
"""

# standard library
from __future__ import division
import sys
import unittest
# other packages
# my modules
import basic_seq_utilities
from general_utilities import value_and_percentages


def define_option_parser():
    """ Populates and returns an optparse option parser object, with __doc__ as the usage string."""
    from optparse import OptionParser
    parser = OptionParser(__doc__)

    ### test options
    parser.add_option('-t','--test_functionality', action='store_true', default=False, 
                      help="Run the built-in unit test suite (ignores all other options/arguments; default %default).")
    parser.add_option('-T','--test_run', action='store_true', default=False, 
                      help="Run on a test input file, check output against reference files. "
                          + "Ignores all other options/arguments. (default %default).")

    ### functionality options
    parser.add_option('-s', '--index_in_sequence', action='store_true', default=False, 
                      help="Look for the index at the beginning of the sequence"
                          +" (otherwise Assumes the index is the last :-separated field of the sequence ID).")
    parser.add_option('-i', '--index_list', metavar='A,B', 
                      help="Comma-separated list of indexes to put in different files (no spaces).")
    parser.add_option('-q', '--quiet', action="store_true", default=False,
                      help="No command-line output (default %default).")
    return parser


def main(args, options):
    """ Run the main functionality of the module (see module docstring for more information), excluding testing.
    The options argument should be generated by an optparse parser.
    """
    try:
        infile, outfile_base = args
    except ValueError:
        parser.print_help()
        sys.exit("\nError: one infile and one outfile base name are required! Got %s"%args)

    indexes = options.index_list.split(',')
    index_OUTFILES = {index: open("%s_%s.fq"%(outfile_base, index), 'w') for index in indexes}
    unmatched_OUTFILE = open("%s_unmatched.fq"%outfile_base, 'w')
    index_counts = {index: 0 for index in indexes}
    unmatched_count = 0
    if options.index_in_sequence:
        index_len = set(len(x) for x in indexes)
        if len(index_len) > 1:
            raise Exception("Indexes need to all have the same lengths!  Found lengths %s from indexes %s"%(index_len, indexes))
        index_len = index_len.pop()
        get_index = lambda name,seq:  seq[:index_len]
        make_output = lambda name, seq, qual, index: ("%s:%s"%(name,index), seq[index_len:], qual[index_len:])
    else:
        get_index = lambda name, seq:  name.split(':')[-1]
        make_output = lambda name, seq, qual, index: (name, seq, qual)
    for (name,seq,qual) in basic_seq_utilities.parse_fastq(infile):
        index = get_index(name, seq) 
        try:
            OUTFILE = index_OUTFILES[index]
            index_counts[index] += 1
        except KeyError:
            OUTFILE = unmatched_OUTFILE
            unmatched_count += 1
        basic_seq_utilities.write_fastq_line(*make_output(name, seq, qual, index), OUTFILE=OUTFILE)
    if not options.quiet:
        total = unmatched_count + sum(index_counts.values())
        print "%s reads:\n%s unmatched\n%s"%(total, value_and_percentages(unmatched_count, [total]), 
                 '\n'.join("%s %s"%(value_and_percentages(count, [total]), index) for (index,count) in index_counts.items()) )


def do_test_run():
    """ Test run: run script on test infile, compare output to reference file."""
    from testing_utilities import run_functional_tests
    test_folder = "_test_inputs"
    # tests in (testname, [test_description,] arg_and_infile_string) format
    test_runs = [ 
        ("split-index", "-i CAGATC,ACCCGG -q %s/%s"%(test_folder, 'with_indexes.fq')),
        ("split-index", "-s -i CAGATC,ACCCGG -q %s/%s"%(test_folder, 'with_indexes_inseq.fq')),  
        # same test name because same reference outfiles
                ]
    # argument_converter converts (parser,options,args) to the correct argument order for main
    argument_converter = lambda parser,options,args: (args, options)
    # use my custom function to run all the tests, auto-detect reference files, compare to output.
    return run_functional_tests(test_runs, define_option_parser(), main, test_folder, 
                                argument_converter=argument_converter, append_to_outfilenames='') 


class Testing(unittest.TestCase):
    """ Runs unit-tests for this module. """

    def test__(self):
        sys.exit("NO UNIT-TESTS FOR THIS MODULE")
    # LATER-TODO add unit-tests!


if __name__=='__main__':
    parser = define_option_parser()
    options,args = parser.parse_args()

    # if run with -t option, do unit tests and quit
    if options.test_functionality:
        print("*** You used the -t option - ignoring all other options/arguments, running the built-in test suite. ***")
        # to run tests for another file, have to use TextTestRunner, not unittest.main -  make a test suite with 
        #   autodetection of all tests (see http://docs.python.org/library/unittest.html#unittest.TestLoader)
        #print("\n * unit-tests for the ______ module")
        #test_suite_1 = unittest.defaultTestLoader.loadTestsFromModule(______
        #unittest.TextTestRunner(verbosity=1).run(test_suite_1)
        # to run tests for current module, just run unittest.main, passing it only the filename 
        #   (by default it takes all of sys.argv and complains about options/arguments it can't recognize)
        print("\n * unit-tests for this module (%s)"%sys.argv[0])
        unittest.main(argv=[sys.argv[0]])   # unittest.main automatically runs sys.exit()

    if options.test_run:
        print("*** You used the -T option - ignoring all other options and running the built-in example test runs. ***")
        test_result = do_test_run()
        sys.exit(test_result)

    # otherwise pass the arguments to the main function
    main(args, options)
