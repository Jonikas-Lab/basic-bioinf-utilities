#! /usr/bin/env python

"""
Given any number of fasta or fastq files, print the N most common sequences in it (either full sequences, or Xbp prefixes) along with their counts as raw numbers and as percentages of the total count.  Optionally only print them if the percentage of the total count exceeds a minimum.
 --Weronika Patena, Feb 2012
USAGE: seq_top_sequence_check.py [options] infile1 [infile2 [infile3 ...]]
"""

# standard library
from __future__ import division
import sys, os
from collections import defaultdict
import unittest
# other packages
from Bio import SeqIO
# my modules
from basic_seq_utilities import check_fasta_fastq_format, get_seq_count_from_collapsed_header


def define_option_parser():
    """ Populates and returns an optparse option parser object, with __doc__ as the usage string."""
    from optparse import OptionParser
    parser = OptionParser(__doc__)

    ### test options
    parser.add_option('-t','--test_functionality', action='store_true', default=False, 
                      help="Run the built-in unit test suite (ignores all other options/arguments; default %default).")
    parser.add_option('-T','--test_run', action='store_true', default=False, 
                      help="Run on a test input file, check output against reference files. "
                          + "Ignores all other options/arguments. (default %default).")

    ### functionality options
    parser.add_option('-l','--seq_length', type='int', default=None, metavar='X',
                      help="Print most common Xbp prefixes (if X is positive) or suffixes (if X is negative) "
                          +"(None - full sequences) (default %default).")
    parser.add_option('-n','--n_to_print', type='int', default=3, metavar='N',
                      help="Print the N most common sequences (default %default).")
    parser.add_option('-m','--min_percent_to_print', type='int', default=None, metavar='M',
                      help="Only print the sequences that constitute over M% of total reads,"
                          +"INSTEAD OF using -n (default %default).")
    parser.add_option('-c','--input_collapsed_to_unique', action='store_true', default=False, 
                      help="Use this to get correct total counts if the infile was collapsed to unique sequences using fastx_collapser, with original sequence counts encoded in the headers (a '>2-572' header means there were 572 identical sequences); default %default).")
    return parser


def subsequence_counts(infile_reader, seq_length=None, input_collapsed_to_unique=False):
    """ Given an iterator of Biopython seq objects and desired subsequence length/end, return subsequence:count dict.

    seq_length: if None, take whole seq; if N>0, take first N bases, if N<0, take last -N bases.
    If input_collapsed_to_unique is True, consider each sequence to be X reads, determined from seq.name, 
     using the format used by fastx_collapser from FastX Toolkit.
    """
    seq_counter = defaultdict(lambda: 0)    # a counter with a default value of 0
    for sequence in infile_reader: 
        N_seqs = get_seq_count_from_collapsed_header(sequence.name) if input_collapsed_to_unique else 1
        # using seq.tostring() to convert Biopython Seq objects to plain strings - Seq objects aren't hashable correctly
        if seq_length > 0:  subsequence = sequence.seq[0:seq_length].tostring()
        else:               subsequence = sequence.seq[seq_length:].tostring()
        seq_counter[subsequence] += N_seqs
    return dict(seq_counter)


def main(infiles, args):
    """ Run the main functionality of the module (see module docstring for more information), excluding testing.
    The options argument should be generated by an optparse parser.
    """

    if not infiles:
        parser.print_help()
        sys.exit("\nError: at least one infile and exactly one outfile are required!")

    if options.seq_length is None:  seqlen_info = ''
    elif options.seq_length>0:      seqlen_info = ' first %sbp'%options.seq_length
    elif options.seq_length<0:      seqlen_info = ' last %sbp'%(-options.seq_length)

    for infile in infiles:
        seq_format = check_fasta_fastq_format(infile)

        with open(infile) as INFILE:
            seq_counter = subsequence_counts(SeqIO.parse(INFILE, seq_format), options.seq_length, options.input_collapsed_to_unique)

        seq_list_by_count = sorted(seq_counter.items(), key=lambda (s,c): c, reverse=True)

        total_seqs = sum(seq_counter.values())

        # if not using the min_percent_to_print option, just print the top N sequences from each file
        if options.min_percent_to_print is None:
            seq_data_list = []
            for i in range(min(options.n_to_print,len(seq_list_by_count))):
                seq,count = seq_list_by_count[i]
                percent = count*100.0/total_seqs
                # "%.2g" is significant-digit-based formatting of floats!!  So 92.12345 is 92%, but 0.00045 is 0.00045%.
                percent_2_sig_digits = str(float("%.2g"%percent))
                if percent_2_sig_digits.endswith(".0"):     percent_2_sig_digits = percent_2_sig_digits[:-2]
                seq_data_list.append("%s%% %s (%d)"%(percent_2_sig_digits, seq, count))
            print " * %s (%s seqs, %s unique%s):"%(infile, total_seqs, len(seq_list_by_count), seqlen_info) 
            print ', '.join(seq_data_list)

        # if using the min_percent_to_print option, just print the top N sequences from each file
        else:
            print "min_percent_to_print NOT IMPLEMENTED!"
            # TODO implement!!


def do_test_run():
    """ Test run: run script on test infile, compare output to reference file."""
    from testing_utilities import run_functional_tests
    test_folder = "test_data"
    sys.exit("NO TESTS DEFINED!")
    # tests in (testname, [test_description,] arg_and_infile_string) format
    test_runs = [ ]
    # argument_converter converts (parser,options,args) to the correct argument order for main
    argument_converter = lambda parser,options,args: (args, options)
    # use my custom function to run all the tests, auto-detect reference files, compare to output.
    return run_functional_tests(test_runs, define_option_parser(), main, test_folder, 
                                argument_converter=argument_converter, append_to_outfilenames='.txt') 
    # LATER-TODO add run-tests!


class Testing(unittest.TestCase):
    """ Unit-tests this module. """

    def test__(self):
        sys.exit("NO UNIT-TESTS FOR THIS MODULE")
    # LATER-TODO add unit-tests!


if __name__=='__main__':
    parser = define_option_parser()
    options,args = parser.parse_args()

    # if run with -t option, do unit tests and quit
    if options.test_functionality:
        print("*** You used the -t option - ignoring all other options/arguments, running the built-in test suite. ***")
        # to run tests for another file, have to use TextTestRunner, not unittest.main -  make a test suite with 
        #   autodetection of all tests (see http://docs.python.org/library/unittest.html#unittest.TestLoader)
        #print("\n * unit-tests for the ______ module")
        #test_suite_1 = unittest.defaultTestLoader.loadTestsFromModule(______
        #unittest.TextTestRunner(verbosity=1).run(test_suite_1)
        # to run tests for current module, just run unittest.main, passing it only the filename 
        #   (by default it takes all of sys.argv and complains about options/arguments it can't recognize)
        print("\n * unit-tests for this module (%s)"%sys.argv[0])
        unittest.main(argv=[sys.argv[0]])   # unittest.main automatically runs sys.exit()

    if options.test_run:
        print("*** You used the -T option - ignoring all other options and running the built-in example test runs. ***")
        test_result = do_test_run()
        sys.exit(test_result)

    # otherwise pass the arguments to the main function
    main(args, options)
